
// // Create and Deploy Your First Cloud Functions
// // https://firebase.google.com/docs/functions/write-firebase-functions
//
// exports.helloWorld = functions.https.onRequest((request, response) => {
//   functions.logger.info("Hello logs!", {structuredData: true});
//   response.send("Hello from Firebase!");
// });

// [START all]
// [START import]
const functions = require("firebase-functions");

// The Firebase Admin SDK to access the Firebase Realtime Database.
const admin = require("firebase-admin");
admin.initializeApp();

const needle = require('needle');

// [END import]


// Timestamp field inserted when an object is created
const GCP_TIMESTAMP_NAME = "gcp_timestamp";

// Get rid of pings after 31 days
const PING_MAX_AGE_S = 2 * 3600; // testing with 2 hours for now. 31 * 24 * 3600;  // 31 days in seconds
const COMPOSITE_KEY_NAME = "lookupKey";

exports.deleteOldItems = functions.region('europe-west1').pubsub.schedule('every 2 hours').onRun( (context) => {
     functions.logger.log('deleteOldItems every 24 hours');

     const cutoff = Math.ceil(Date.now() / 1000) - PING_MAX_AGE_S;
     functions.logger.log("Cutoff : " + cutoff)
     const pings = admin.database().ref('ping').orderByChild(GCP_TIMESTAMP_NAME).endAt(cutoff).limitToFirst(2000);
     // create a map with all children that need to be removed
     const updates = {};
     pings.once("value", function(pings) {
          pings.forEach(ping => {
               functions.logger.log(ping.key);
               updates[ping.key] = null;
          });
          // remove them all
          var delOld = admin.database().ref('ping');
          delOld.update(updates, a => {
               functions.logger.log(a);         
          });
     });

    return null;
});

exports.checkPing = functions.region('europe-west1').pubsub.schedule('every 5 minutes').onRun((context) => {
     functions.logger.log('CheckPing function triggered every 5 minutes');
     const now = Math.ceil(Date.now() / 1000);
     const lastHour = now - 3900;  // Actually one hour and 5 mn which is the ping periodicity (to avoid edge issue)
     const modules = admin.database().ref('module');
     modules.once('value', function (modules) {
          modules.forEach(function (module) {
               const mac = module.child("mac").val();
               const tu = module.child("tu").val();
               const ta = module.child("ta").val();
               const moduleName = module.child("name").val();
               functions.logger.log('Checking pings on module ' + mac);
               const moduleLastHourPings = admin.database().ref('ping')
                    .orderByChild(COMPOSITE_KEY_NAME).startAt(compositeKeyValue(mac, lastHour))
                    .endAt(compositeKeyValue(mac, now));

               moduleLastHourPings.once('value', function (pings) {
                    const size = pings.numChildren();
                    functions.logger.log("Size: " + size);
                    if (size < 12) {
                         functions.logger.log("ALERT MODULE " + moduleName + " STOPPED !");
                         sendNotification(tu, ta, "Alert " + moduleName, "Module no longer online");
                    }
               });
          });
     });
     return null;

});

// add a true timestamp because the one generated by the module is crappy (need to fix)
exports.setTimestampOnCreate = functions.region('europe-west1').database.ref('/{type}/{objectId}').onCreate((snapshot, context) => {
     functions.logger.log('setTimestampOnCreate');
     const timestamp = Math.ceil(Date.now() / 1000);
     // To be able to fetch pings by module AND with a start/end criteria, add a composite field for that
     if (context.params.type == "ping") {
          functions.logger.log('ping object created');
          const mac = snapshot.child("mac").val();
          functions.logger.log('mac ' + mac);
          snapshot.ref.child(COMPOSITE_KEY_NAME).set(compositeKeyValue(mac, timestamp));
     }
     return snapshot.ref.child(GCP_TIMESTAMP_NAME).set(timestamp);
});

function compositeKeyValue(mac, timestamp) {
     return mac + "_" + timestamp;
}

// Update the added timestamp on the module record
exports.setTimestampOnUpdate = functions.region('europe-west1').database.ref('/module/{objectId}').onUpdate((change, context) => {
     // when deleting
     if (!change.after.exists() != null) {
          return null;
     }
     // called because of the update of the timestamp => do nothing
     if (change.after.child(GCP_TIMESTAMP_NAME).val() != null) {
          return null;
     }
     functions.logger.log('setTimestampOnUpdate');
     // warning this triggers a new call to this onUpdate method
     return change.before.ref.child(GCP_TIMESTAMP_NAME).set(Math.ceil(Date.now() / 1000));
});

// For now, notifs are sent directly from the ESP to Pushover
//  exports.sendNotifOnAlert = functions.database.ref('/alert/{alertId}').onCreate((snapshot, context) => {
//    // Grab the current value of what was written to the Realtime Database.
//    const original = snapshot.val();
//    functions.logger.log("Sending an alert");

//    needle('post', 'https://api.pushover.net/1/messages.json', data, {json: true})
//    .then((res) => {
//       functions.logger.log(`Status: ${res.statusCode}`);
//       functions.logger.log('Body: ', res.body);
//    }).catch((err) => {
//       functions.logger.error(err);
//    });
//  });

function sendNotification(tu, ta, title, message) {
     functions.logger.log('sendNotification');
     if (tu && ta) {
          const data = {
               "token": ta,
               "user": tu,
               "message": message,
               "title": title
          };
          needle('post', 'https://api.pushover.net/1/messages.json', data, { json: true })
               .then((res) => {
                    functions.logger.log(`Status: ${res.statusCode}`);
                    functions.logger.log('Body: ', res.body);
               }).catch((err) => {
                    functions.logger.error(err);
               });
     }
}